<feed xmlns="http://www.w3.org/2005/Atom"> <id>/docs/</id><title>Club Robot</title><subtitle>here you can find INSA Toulouse Club Robot's documentation</subtitle> <updated>2023-11-18T22:59:53+01:00</updated> <author> <name>Club Robot INSA Toulouse</name> <uri>/docs/</uri> </author><link rel="self" type="application/atom+xml" href="/docs/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="/docs/"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2023 Club Robot INSA Toulouse </rights> <icon>/docs/assets/img/favicons/favicon.ico</icon> <logo>/docs/assets/img/favicons/favicon-96x96.png</logo> <entry><title>First test to try the documentation</title><link href="/docs/posts/Test/" rel="alternate" type="text/html" title="First test to try the documentation" /><published>2023-11-18T15:55:00+01:00</published> <updated>2023-11-18T15:55:00+01:00</updated> <id>/docs/posts/Test/</id> <content src="/docs/posts/Test/" /> <author> <name>{"name"=>"Club Robot", "link"=>"https://github.com/ClubRobotInsat"}</name> </author> <category term="2023" /> <category term="test" /> <summary> This is a test to try the documentation. </summary> </entry> <entry><title>CAN Bus avec Raspberry Pi</title><link href="/docs/posts/CAN-Bus-avec-RaspberryPi/" rel="alternate" type="text/html" title="CAN Bus avec Raspberry Pi" /><published>2022-10-21T05:26:00+02:00</published> <updated>2022-10-21T11:26:30+02:00</updated> <id>/docs/posts/CAN-Bus-avec-RaspberryPi/</id> <content src="/docs/posts/CAN-Bus-avec-RaspberryPi/" /> <author> <name>Club Robot INSA Toulouse</name> </author> <category term="2022" /> <category term="can-bus" /> <summary> 1. Brancher le Composant intermédiaire CAN - RaspberryPI 2. Commandes de test en bash 3. Librairie python CANpy ? </summary> </entry> <entry><title>Network Protocol Definition</title><link href="/docs/posts/Network-Protocol/" rel="alternate" type="text/html" title="Network Protocol Definition" /><published>2022-04-08T00:00:00+02:00</published> <updated>2022-04-08T00:00:00+02:00</updated> <id>/docs/posts/Network-Protocol/</id> <content src="/docs/posts/Network-Protocol/" /> <author> <name>{"name"=>"Joel Imbergamo Guasch", "link"=>"https://github.com/joelimgu"}</name> </author> <category term="2022" /> <category term="can-bus" /> <summary> Ce document décrit le fonctionnement du protocole utilisé pour les communications entre les microcontroleurs du robot et la raspi. C’est un protocole sans pertes c.-à-d. toutes les trames sont vérifiées avec un paquet d’acquittement avant de les marqués comme bien envoyés. Trame sur 64 bits           4b 4b 3b ... </summary> </entry> <entry><title>Notre microcontrôleur: le STM32F103</title><link href="/docs/posts/Microcontroleur-STM32/" rel="alternate" type="text/html" title="Notre microcontrôleur: le STM32F103" /><published>2022-03-17T00:00:00+01:00</published> <updated>2022-04-08T19:14:07+02:00</updated> <id>/docs/posts/Microcontroleur-STM32/</id> <content src="/docs/posts/Microcontroleur-STM32/" /> <author> <name>{"name"=>"Andrea PEREZ FERNANDEZ", "link"=>"https://github.com/andreapefe"}</name> </author> <category term="2022" /> <category term="can-bus" /> <summary> Pour gérer les actionneurs, moteurs et capteurs, nous utilisons des microcontrôleurs répartis dans tout le robot. Parmi ceux existant nous utilisons des STM32F103 comme dans les TPs de 4A à l’INSA. Un microcontrôleur est un ”petit” maid qui ne possède pas de système d’exploitation, il est vide. Ainsi, c’est nous qui devons écrire le code qui va s’exécuter sur lui, le firmaware (entre soft et h... </summary> </entry> <entry><title>CAN Bus</title><link href="/docs/posts/CAN-Bus-driver/" rel="alternate" type="text/html" title="CAN Bus" /><published>2022-03-15T12:28:00+01:00</published> <updated>2022-10-21T11:26:00+02:00</updated> <id>/docs/posts/CAN-Bus-driver/</id> <content src="/docs/posts/CAN-Bus-driver/" /> <author> <name>{"name"=>"Andrea PEREZ FERNANDEZ", "link"=>"https://github.com/andreapefe"}</name> </author> <category term="2022" /> <category term="can-bus" /> <summary> 1. Presentation du protocole Le protocole utilisé pour communiquer entre les microcontrôleurs STM32 et le “cerveau” du robot, la Raspberry Pi est le CAN Bus. Très utilisé en industrie notamment dans le domaine de l’automobile, nous l’avons choisi car il permet de transmettre les messages avec juste 2 cables nommé CAN High et CAN Low. 1.1. Avantages Ce protocole a de nombreux avantages : Il ... </summary> </entry> </feed>
