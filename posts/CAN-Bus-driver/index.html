<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="CAN Bus" /><meta name="author" content="Andrea PEREZ FERNANDEZ" /><meta property="og:locale" content="en" /><meta name="description" content="1. Presentation du protocole Le protocole utilisé pour communiquer entre les microcontrôleurs STM32 et le “cerveau” du robot, la Raspberry Pi est le CAN Bus. Très utilisé en industrie notamment dans le domaine de l’automobile, nous l’avons choisi car il permet de transmettre les messages avec juste 2 cables nommé CAN High et CAN Low." /><meta property="og:description" content="1. Presentation du protocole Le protocole utilisé pour communiquer entre les microcontrôleurs STM32 et le “cerveau” du robot, la Raspberry Pi est le CAN Bus. Très utilisé en industrie notamment dans le domaine de l’automobile, nous l’avons choisi car il permet de transmettre les messages avec juste 2 cables nommé CAN High et CAN Low." /><link rel="canonical" href="/docs/posts/CAN-Bus-driver/" /><meta property="og:url" content="/docs/posts/CAN-Bus-driver/" /><meta property="og:site_name" content="Club Robot" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-03-15T12:28:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="CAN Bus" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"Andrea PEREZ FERNANDEZ"},"description":"1. Presentation du protocole Le protocole utilisé pour communiquer entre les microcontrôleurs STM32 et le “cerveau” du robot, la Raspberry Pi est le CAN Bus. Très utilisé en industrie notamment dans le domaine de l’automobile, nous l’avons choisi car il permet de transmettre les messages avec juste 2 cables nommé CAN High et CAN Low.","url":"/docs/posts/CAN-Bus-driver/","@type":"BlogPosting","headline":"CAN Bus","dateModified":"2022-10-21T11:26:00+02:00","datePublished":"2022-03-15T12:28:00+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"/docs/posts/CAN-Bus-driver/"},"@context":"https://schema.org"}</script><title>CAN Bus | Club Robot</title><link rel="apple-touch-icon" sizes="180x180" href="/docs/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/docs/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/docs/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/docs/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/docs/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Club Robot"><meta name="application-name" content="Club Robot"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/docs/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/docs/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/docs/" alt="avatar" class="mx-auto"> <img src="/docs/assets/img/favicons/android-chrome.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/docs/">Club Robot</a></div><div class="site-subtitle font-italic">Documentation</div></div><ul class="w-100"><li class="nav-item"> <a href="/docs/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/docs/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/docs/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/docs/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/docs/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/ClubRobotInsat" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://instagram.com/club.robot" aria-label="instagram" target="_blank" rel="noopener"> <i class="fab fa-instagram"></i> </a> <a href="https://discord.gg/c2btEp74ft" aria-label="discord" > <i class="fab fa-discord"></i> </a> <a href="/docs/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/docs/"> Home </a> </span> <span>CAN Bus</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>CAN Bus</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/andreapefe">Andrea PEREZ FERNANDEZ</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1647343680" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-03-15 </em> </span> <span> Updated <em class="timeago" data-ts="1666344360" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-10-21 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1215 words"> <em>6 min</em> read</span></div></div></div><div class="post-content"><h1 id="1-presentation-du-protocole">1. Presentation du protocole</h1><p>Le protocole utilisé pour communiquer entre les microcontrôleurs STM32 et le “cerveau” du robot, la Raspberry Pi est le CAN Bus. Très utilisé en industrie notamment dans le domaine de l’automobile, nous l’avons choisi car il permet de transmettre les messages avec juste 2 cables nommé CAN High et CAN Low.</p><h2 id="11-avantages">1.1. Avantages <a href="#11-avantages" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Ce protocole a de nombreux avantages :</p><ul><li>Il présente une grande fiabilité. En effet, il implémente 5 moyens différents de détection d’erreurs et est capable de détecter une erreur en 20 bits. Ainsi pour notre débit de 115Kb/, une erreur est détecté moins de 1 ms. Elles sont de plus très rares grâce aux propriétés électromagnétiques du bus.<li>L’acquittement de reception est gérer par le hardware associé au CAN. DOnc il n’y a pas besoin de traiter les ACK logiciellement. Le renvoi de message en cas d’échec d’envoi se fait aussi par hardware.<li>Débits suffisamment élevés pouvant atteindre un 1 Mbit/s.<li>Gestion des collisions entre messages. Si plusieurs machines sur le réseau décide d’envoyer un message en même temps, le message le plus prioritaire sera envoyer en premier (cf. partie 1.2.).</ul><h2 id="12-format-des-trames">1.2. Format des trames <a href="#12-format-des-trames" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Les trames CAN sont composé de 2 parties, la partie ID et la partie données. Cependant, le concept de ID ne correspond pas à l’idée d’avoir un identificateur pour les différentes machines du réseau. En revanche, il se réfère à la priorité des messages qui permet de choisir quel message sera envoyer en premier en cas de collisions dans le réseau. Ce sera le message de plus haute priorité qui sera émis en cas de conflit. Dans la documentation, on se réfère à cette priorité comme l’identificateur de message (ID) même si ce n’est pas exactement ça. Il existe deux versions de ID (priorité) selon la quel la taille du champ priorité/ID des messages change :</p><ul><li>Standard CAN ID: Taille de 11 bits<li>Extended CAN ID: Taille de 29 bits</ul><p>La zone data a une taille maximale entre 0 et 8 octets soit 64 bits au total.</p><p>Pour avoir plus d’informations techniques sur le CAN vous pouvez <a href="https://www.ti.com/lit/an/sloa101b/sloa101b.pdf?ts=1633140726383&amp;ref_url=https%253A%252F%252Fwww.google.com%252F/">clickez ici</a></p><h1 id="2-utilisé-le-can-bus-avec-des-stm32">2. Utilisé le CAN BUS avec des STM32</h1><h2 id="21-comment-utilsier-le-périphérique-bxcan">2.1. Comment utilsier le périphérique bxCAN <a href="#21-comment-utilsier-le-périphérique-bxcan" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Notre microcontroleur STM32 possède deux périphériques internes capables de faire du CAN Bus appelés bxCAN. Si on ne fait pas de remap sur notre STM32 ils sont accesibles via les ports suivants:</p><div class="table-wrapper"><table><thead><tr><th>nº CAN<th>TXD<th>RXD<tbody><tr><td>CAN 1<td>PA12<td>PA11<tr><td>CAN 2<td>PB13<td>PB12</table></div><p>Pour les autres ports regarder la page 176 de <a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwjO74XN7cj2AhWeQkEAHeoIDS8QFnoECAUQAQ&amp;url=https%3A%2F%2Fwww.st.com%2Fresource%2Fen%2Freference_manual%2Fcd00171190-stm32f101xx-stm32f102xx-stm32f103xx-stm32f105xx-and-stm32f107xx-advanced-arm-based-32-bit-mcus-stmicroelectronics.pdf&amp;usg=AOvVaw2kF0T1D3TzsgvgnX7fvMku">la doc de la STM32F103</a></p><p>Ils peuvent être configurés pour fonctionner avec des Standard ou Extended ID.</p><p>Cependant, on ne peut pas l’utiliser tout seul, il faut lui associé un composant appelé CAN Transreceiver pour pouvoir s’en servir. Nous utilisons le modèle <a href="https://ww1.microchip.com/downloads/en/DeviceDoc/20001667G.pdf">MCP2551</a> qui est l’ancienne version du MCP2552 utilisé mais qui marche toujours. Il est branché au CAN de la forme suivante:</p><p><img data-src="/docs/assets/img/posts/CAN-bus/schema_mcp.png" alt="Connexions MCP2551" data-proofer-ignore></p><p>Vous observerez que nous connectons les deux poins CANH et CANL sur un circuit fermé par deux résistances de 120 Ohm. En effet, il n’a pas de sens envoyé ou recevoir tous les messages circulent sur ce milieu et sont récupérés par toutes les STM32 si elles sont en reception. On appelle ça un circuit bouchon.</p><h2 id="22-comment-filtrer-des-messages">2.2. Comment filtrer des messages <a href="#22-comment-filtrer-des-messages" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Ces périphériques bxCAN ont des fonctionnalités supplémentaires assez intéressantes en termes de filtrage de messages. Elles sont très utiles, car les messages sont directement filtrés par le hardware ce qui allege la charge de travail du processeur. Au club, nous utilisons filtrage par ID et/ou Masque. Il existe plusieurs banques ou configurer les filtres (cf. doc officielle) donc les possibilités sont très nombreuses. Nous n’utilisons qu’une seule banque pour filtrer nos messages parce que c’est largement suffisant pour notre application.</p><p>Le filtrage par ID est simple il suffit d’indiquer au programme que nous voulons juste recevoir des messages avec un ID particuler. Sur rust on le configure de la forme suivante :</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">const</span> <span class="nb">u16</span> <span class="n">ID</span> <span class="c1">//inf à 2¹¹ si Standard ID</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">filters</span> <span class="o">=</span> <span class="n">can1</span><span class="nf">.modify_filters</span><span class="p">();</span>
<span class="n">filters</span><span class="nf">.enable_bank</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> 
    <span class="nn">BankCOnfig</span><span class="p">::</span><span class="nf">List16</span><span class="p">([</span><span class="nn">ListEntry16</span><span class="p">::</span><span class="nf">data_frames_with_id</span><span class="p">(</span><span class="nn">StandardId</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">MY_ID</span><span class="p">)</span><span class="nf">.unwarp</span><span class="p">())]));</span>
</pre></table></code></div></div><p>Le filtrage par Masque/ID et de filtrer de forme plus fine. Elle se compose d’un masque qui nous indique quels bits il faut regarder (bit à 1) et lesquels on peut ignorer (à 0). L’ID nous donne la valeur que devrait avoir ces bits. Ainsi par exemple si nous voulons filtrer de sorte à avoir juste des messages avec des IDs pairs nous configurons notre masque et notre ID tel que (pour des ID standards à 11 bits):</p><ul><li>Masque : 0x001 (dernier bit à 1)<li>ID : 0x000 (dernier bit à 0)</ul><p>Avec cette configuration, nous allons recevoir que des messages avec un ID qui ont le dernier bit à 0 soit des ID pairs. De forme analogue si on configure les registres tels que :</p><ul><li>Masque : 0x001 (dernier bit à 1)<li>ID : 0x001 (dernier bit à 0)</ul><p>Nous allons recevoir que des messages à ID impair.</p><p>Pour faire cette configuration nous utilisons le code suivant :</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">let</span> <span class="k">mut</span> <span class="n">filters</span> <span class="o">=</span> <span class="n">can1</span><span class="nf">.modify_filters</span><span class="p">();</span>
<span class="n">filters</span><span class="nf">.enable_bank</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nn">Mask32</span><span class="p">::</span><span class="nf">frames_with_std_id</span><span class="p">(</span>
    <span class="nn">StandardId</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">0x000</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">(),</span> <span class="c1">//ID</span>
    <span class="nn">StandardId</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">0x001</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()));</span> <span class="c1">//masque</span>
</pre></table></code></div></div><h1 id="3-comment-tester-le-can-bus">3. Comment tester le CAN bus</h1><h2 id="31-carte-de-prototypage">3.1. Carte de prototypage <a href="#31-carte-de-prototypage" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Pour tester le CAN Bus avant de l’embarqué nous avons fabriqué 3 cartes de protypage (ID de carte AAB) qui permettent d’utiliser le CAN Transreceiver avec une plaquette d’essai . Vous trouverez le circuit et le Typhoon pour la fabriquée <a href="https://github.com/ClubRobotInsat/Cartes_2022/tree/master/ID_AAB_CAN_PrototypageGrand">ici</a>. Les MCP2551 sont des composants montés en surface (CMS) et donc on n’a pas accès aux différents PIN directement.</p><h2 id="32-mise-en-route">3.2. Mise en route <a href="#32-mise-en-route" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Il faut brancher la carte et le bus tel qu’indiqué dans le 2.1. Il ne faut surtout pas oublier les resistances bouchons en bord du bus de 120 Ohm au pin RS. Il faut faire gaffe aussi à bien brancher la résistance de 10 kOhm, en effet, c’est elle qui permet de fixer mode de fonctionnement du MCP (High speed, Slope-control et Standby Mode). Nous sommes en Slope-Control et on a fixé une vitesse de balayage (slew-rate) de environ 23V/us. Cette vitesse de balayage limite le débit du CAN Bus qu’on fixe logiciellement.</p><p><strong>Il existe déjà un banc test déjà brancher pour tester</strong>. Donc normalement pas besion de refaire tout ceci.</p><p>On alimente tout le circuit en 5V pour être sûr d’avoir une tension stable pour les MCP. Il faut mettre au moins 2 MCP sur le réseau. On ne peut pas tester le CAN Bus seul car il a besoin de recevoir des ACK pour être sûrs que les messages ont été bien envoyés.</p><p>Pour commencer à envoyer des messages et à en recevoir, il faut flasher la STM32 avec le code qui est dans la branche can-bus de ce <a href="https://github.com/ClubRobotInsat/robot_rust_2022">repo Github</a>. Le code est commenté et devrait être semi-compréhensible. Il permet d’afficher sur la console du debugger les messages reçus. Le code pour envoyer des messages est commenté et présent dans le loop. Si votre STM est déjà alimenté par les +5V des MCP vous pouvez débrancher le pin 3V3 du câble de flash. Il n’est pas nécessaire.</p><h2 id="33-configurations-possibles">3.3. Configurations possibles <a href="#33-configurations-possibles" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Vous pouvez soit flasher deux STM entre elles et les faire communiquer mais vous pouvez aussi connecter la raspberry Pi avec son module CAN aussi. Pour voir comment faire du CAN avec la raspberry Pi se référer à [cette page]</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/docs/categories/2022/'>2022</a>, <a href='/docs/categories/can-bus/'>can-bus</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/docs/tags/post/" class="post-tag no-text-decoration" >post</a> <a href="/docs/tags/elec-soft/" class="post-tag no-text-decoration" >elec-soft</a> <a href="/docs/tags/can-bus/" class="post-tag no-text-decoration" >can-bus</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=CAN Bus - Club Robot&amp;url=/docs/posts/CAN-Bus-driver/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=CAN Bus - Club Robot&amp;u=/docs/posts/CAN-Bus-driver/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=/docs/posts/CAN-Bus-driver/&amp;text=CAN Bus - Club Robot" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/docs/posts/CAN-Bus-avec-RaspberryPi/">CAN Bus avec Raspberry Pi</a><li><a href="/docs/posts/CAN-Bus-driver/">CAN Bus</a><li><a href="/docs/posts/Microcontroleur-STM32/">Notre microcontrôleur: le STM32F103</a><li><a href="/docs/posts/tirage-cartes/">Tirage cartes électroniques au FabLab</a><li><a href="/docs/posts/some-help-for-redaction/">Some help for redaction</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/docs/tags/post/">post</a> <a class="post-tag" href="/docs/tags/elec-soft/">elec-soft</a> <a class="post-tag" href="/docs/tags/can-bus/">can-bus</a> <a class="post-tag" href="/docs/tags/tutorial/">tutorial</a> <a class="post-tag" href="/docs/tags/info/">info</a> <a class="post-tag" href="/docs/tags/d%C3%A9bogage/">débogage</a> <a class="post-tag" href="/docs/tags/elec-hard/">elec-hard</a> <a class="post-tag" href="/docs/tags/fablab/">fablab</a> <a class="post-tag" href="/docs/tags/jekyll/">jekyll</a> <a class="post-tag" href="/docs/tags/microcontroleur/">microcontroleur</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/docs/posts/CAN-Bus-avec-RaspberryPi/"><div class="card-body"> <em class="timeago small" data-ts="1666322760" > 2022-10-21 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>CAN Bus avec Raspberry Pi</h3><div class="text-muted small"><p> 1. Brancher le Composant intermédiaire CAN - RaspberryPI 2. Commandes de test en bash 3. Librairie python CANpy ?</p></div></div></a></div><div class="card"> <a href="/docs/posts/saleae-logic-analyzer/"><div class="card-body"> <em class="timeago small" data-ts="1646953200" > 2022-03-11 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Saleae logic analyzer</h3><div class="text-muted small"><p> Saleae logic analyzer Débogage du bus CAN et protocoles de communication en général. Installer le software saleae (sous linux) ⇒ pas besoin de software additionnel pour exécuter (app...</p></div></div></a></div><div class="card"> <a href="/docs/posts/Microcontroleur-STM32/"><div class="card-body"> <em class="timeago small" data-ts="1647471600" > 2022-03-17 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Notre microcontrôleur: le STM32F103</h3><div class="text-muted small"><p> Pour gérer les actionneurs, moteurs et capteurs, nous utilisons des microcontrôleurs répartis dans tout le robot. Parmi ceux existant nous utilisons des STM32F103 comme dans les TPs de 4A à l’INSA....</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/docs/posts/tirage-cartes/" class="btn btn-outline-primary" prompt="Older"><p>Tirage cartes électroniques au FabLab</p></a> <a href="/docs/posts/Microcontroleur-STM32/" class="btn btn-outline-primary" prompt="Newer"><p>Notre microcontrôleur: le STM32F103</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/ClubRobotInsat">Club Robot INSA Toulouse</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/docs/tags/post/">post</a> <a class="post-tag" href="/docs/tags/elec-soft/">elec-soft</a> <a class="post-tag" href="/docs/tags/can-bus/">can-bus</a> <a class="post-tag" href="/docs/tags/tutorial/">tutorial</a> <a class="post-tag" href="/docs/tags/info/">info</a> <a class="post-tag" href="/docs/tags/d%C3%A9bogage/">débogage</a> <a class="post-tag" href="/docs/tags/elec-hard/">elec-hard</a> <a class="post-tag" href="/docs/tags/fablab/">fablab</a> <a class="post-tag" href="/docs/tags/jekyll/">jekyll</a> <a class="post-tag" href="/docs/tags/microcontroleur/">microcontroleur</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/docs/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/docs/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/docs/app.js"></script>
