[ { "title": "First test to try the documentation", "url": "/docs/posts/Test/", "categories": "2023, test", "tags": "post, test", "date": "2023-11-18 15:55:00 +0100", "snippet": "This is a test to try the documentation." }, { "title": "CAN Bus avec Raspberry Pi", "url": "/docs/posts/CAN-Bus-avec-RaspberryPi/", "categories": "2022, can-bus", "tags": "post, elec-soft, can-bus, raspberryPi, protocol, info", "date": "2022-10-21 05:26:00 +0200", "snippet": "1. Brancher le Composant interm√©diaire CAN - RaspberryPI2. Commandes de test en bash3. Librairie python CANpy ?" }, { "title": "Network Protocol Definition", "url": "/docs/posts/Network-Protocol/", "categories": "2022, can-bus", "tags": "elec-soft, can-bus, info, network", "date": "2022-04-08 00:00:00 +0200", "snippet": "Ce document d√©crit le fonctionnement du protocole utilis√© pour les communications entre les microcontroleurs du robot et la raspi.C‚Äôest un protocole sans pertes c.-√†-d. toutes les trames sont v√©rifi√©es avec un paquet d‚Äôacquittement avant de les marqu√©s comme bien envoy√©s. Trame sur 64 bits ¬† ¬† ¬† ¬† ¬† 4b 4b 3b 4b 1b 48b ID_dest ID_sender ID_mess seq_num ACK data Name Type Explication ID_dest unsigned (4bit) ID de la STM auquelle le message va dirig√© ID_sender unsigned (4bit) ID de la STM qui envoie le message ID_mess unsigned (3bit) Identificateur unique du message. La combinaison (ID_sender,ID_des,ID_mess) doit √™tre unique. cela veut dire qu‚Äôon ne peux pas envoyer un message avec la m√™me id√©e tant qu‚Äôon a pas liber√©e la ID ( la ID est liber√©e quand on a re√ßu tous les ACK des trames du message ) seq_num unsigned (4bit) Numero de sequence de la trame. ‚ö† On le decremente. Ce numero indique la l‚Äôordre de la trame pour permetre de reconstruire le message bien ordon√©. On le decremante, cela implique que la premi√®re trame indique le n√∫mero de trames qui forment le message. ACK bool (1b) Indique si la trame est un paquet d‚Äôacquittement ExamplesSTM(ID:4) &amp;lt;‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî-&amp;gt; STM(ID:12)STM4 evnoye un message √† STM12:Notre message: Club_Robot_INSATTaille du message = 16bytes ( cod√© en ASCII )Cela veut dire qu‚Äôil faut diviser notre message en 3 trames de 6 bytes. ( 16 / 6 = 3 ) ( on pourrait coder des espaces sans problemme mais c‚Äôest compliquer √† les √©crire d‚Äôuna fa√ßon claire pour l‚Äôexample üòÖ)3 messages =&amp;gt; seq_num = 2 de la premi√®re trameOn prend l‚Äôid_mess = 0, car c‚Äôest le premier message qu‚Äôon evoye.Trames envoy√©s par le STM4: [12,4,0,2,0,C,l,u,b,_,R] [12,4,0,1,0,o,b,o,t,_,I] [12,4,0,0,0,N,S,A,T,0,0] -&amp;gt; On rempli avec des 0‚Äôs le reste du messageTrames envoy√©es par le STM12 ( ACK ): [4,12,0,2,1,0,0,0,0,0,0] [4,12,0,1,1,0,0,0,0,0,0] [4,12,0,0,1,0,0,0,0,0,0]Si maintenant on veut envoyer un autre message il faut juste augmenter l‚Äôid_mess mod 7." }, { "title": "Notre microcontr√¥leur: le STM32F103", "url": "/docs/posts/Microcontroleur-STM32/", "categories": "2022, can-bus", "tags": "post, tutorial, elec-soft, stm32, microcontroleur", "date": "2022-03-17 00:00:00 +0100", "snippet": "Pour g√©rer les actionneurs, moteurs et capteurs, nous utilisons des microcontr√¥leurs r√©partis dans tout le robot. Parmi ceux existant nous utilisons des STM32F103 comme dans les TPs de 4A √† l‚ÄôINSA.Un microcontr√¥leur est un ‚Äùpetit‚Äù maid qui ne poss√®de pas de syst√®me d‚Äôexploitation, il est vide. Ainsi, c‚Äôest nous qui devons √©crire le code qui va s‚Äôex√©cuter sur lui, le firmaware (entre soft et hardware) puis le transmettre √† ce dernier.Cette action se nomme flasher le contr√¥leur. Une fois le contr√¥leur a √©t√© flash√© il garde le programme √† ex√©cuter dans sa m√©moire morte et une fois mis sur tension il s‚Äôex√©cutera.Si vous observez les microcontr√¥leurs au Club, vous vous rendrez compte qu‚Äôils poss√®dent un gran nombre de pins (48 dans notre cas). Chacun porte un nom sp√©cial et a aussi des fonctions d√©sign√©es. Nous avons des pins de GND, de source de tension, mais aussi des GPIOs (General Purpose Input Output) qui nous permettent de communiquer avec l‚Äôext√©rieur. Ces derniers peuvent √™tre configur√©s par le programmeur pour r√©pondre √† ses besoins. Pour fixer cette configuration, nous devons affecter certaines valeurs sp√©ciales aux registres de control de chacun deses ports. Gr√¢ce √† la librairie HAL (High Applicative Layer) nous n‚Äôaurons pas besoin de le faire directement, mais en appelant leurs m√©thodes. Regarder le code firmware comment√© pour comprendre les √©tapes de configuration.De plus, selon le p√©riph√©rique que nous souhaitons utilis√© ces ports vont devoir √™tre configur√© selon une configuration pr√©cise. Pour trouver toutes les configurations pour chaque p√©riph√©rique il faut regarder dans le reference manual RM0008 √† la page 166. Pour voir sur quels pins sont branch√©s tous les p√©riph√©riques (USART, Timer, etc..) il faut voir la page 176.Les diff√©rentes configurations des ports GPIO possibles sont : Mode Input Utilisation Floating Input Mode standard, prend l‚Äôentr√©e tel quel sans tensions de r√©f√©rence Input with pull-up/pull-down Entr√©e digital avec r√©ference au GND ou √† la tension de polarisation (Vcc) selon √† quel potentiel on branche la r√©sistance Analog Input Pour signaux analogiques (ADC ou CAN) Mode Output Utilisation General purpose output push-pull Le composant sera aliment√© par pin de sortie General purpose output Open-drain Composant aliment√© par nous. Besoin d‚Äôune r√©sistance pull-up (au VCC) pour assurer le niveau logique ‚Äô1‚Äô Alternate function output Push-pull Configuration sp√©ciale pour utiliser certains p√©riph√©riques Alternate function output Open-drain Configuration sp√©ciale pour utiliser certains p√©riph√©riques. V√©rifier le besoin d‚Äôun r√©sistance pull-up Dernier point important sur le clock. C‚Äôest le signal qui synchronise et fait marcher tout le syst√®me. Ainsi vous observerez dans le code qu‚Äôavant d‚Äôutiliser n‚Äôimporte quel GPIO il faut alimenter leur branche par une clock pour les activer. Chaque p√©riph√©rique est sur une des deux branches qui existent avec chacune une fr√©quence maximale diff√©rente de fonctionnement (ceci est important pour les protocoles de communication notamment de type USART)." }, { "title": "CAN Bus", "url": "/docs/posts/CAN-Bus-driver/", "categories": "2022, can-bus", "tags": "post, elec-soft, can-bus", "date": "2022-03-15 12:28:00 +0100", "snippet": "1. Presentation du protocoleLe protocole utilis√© pour communiquer entre les microcontr√¥leurs STM32 et le ‚Äúcerveau‚Äù du robot, la Raspberry Pi est le CAN Bus. Tr√®s utilis√© en industrie notamment dans le domaine de l‚Äôautomobile, nous l‚Äôavons choisi car il permet de transmettre les messages avec juste 2 cables nomm√© CAN High et CAN Low.1.1. AvantagesCe protocole a de nombreux avantages : Il pr√©sente une grande fiabilit√©. En effet, il impl√©mente 5 moyens diff√©rents de d√©tection d‚Äôerreurs et est capable de d√©tecter une erreur en 20 bits. Ainsi pour notre d√©bit de 115Kb/, une erreur est d√©tect√© moins de 1 ms. Elles sont de plus tr√®s rares gr√¢ce aux propri√©t√©s √©lectromagn√©tiques du bus. L‚Äôacquittement de reception est g√©rer par le hardware associ√© au CAN. DOnc il n‚Äôy a pas besoin de traiter les ACK logiciellement. Le renvoi de message en cas d‚Äô√©chec d‚Äôenvoi se fait aussi par hardware. D√©bits suffisamment √©lev√©s pouvant atteindre un 1 Mbit/s. Gestion des collisions entre messages. Si plusieurs machines sur le r√©seau d√©cide d‚Äôenvoyer un message en m√™me temps, le message le plus prioritaire sera envoyer en premier (cf. partie 1.2.).1.2. Format des tramesLes trames CAN sont compos√© de 2 parties, la partie ID et la partie donn√©es. Cependant, le concept de ID ne correspond pas √† l‚Äôid√©e d‚Äôavoir un identificateur pour les diff√©rentes machines du r√©seau. En revanche, il se r√©f√®re √† la priorit√© des messages qui permet de choisir quel message sera envoyer en premier en cas de collisions dans le r√©seau. Ce sera le message de plus haute priorit√© qui sera √©mis en cas de conflit. Dans la documentation, on se r√©f√®re √† cette priorit√© comme l‚Äôidentificateur de message (ID) m√™me si ce n‚Äôest pas exactement √ßa. Il existe deux versions de ID (priorit√©) selon la quel la taille du champ priorit√©/ID des messages change : Standard CAN ID: Taille de 11 bits Extended CAN ID: Taille de 29 bitsLa zone data a une taille maximale entre 0 et 8 octets soit 64 bits au total.Pour avoir plus d‚Äôinformations techniques sur le CAN vous pouvez clickez ici2. Utilis√© le CAN BUS avec des STM322.1. Comment utilsier le p√©riph√©rique bxCANNotre microcontroleur STM32 poss√®de deux p√©riph√©riques internes capables de faire du CAN Bus appel√©s bxCAN. Si on ne fait pas de remap sur notre STM32 ils sont accesibles via les ports suivants: n¬∫ CAN TXD RXD CAN 1 PA12 PA11 CAN 2 PB13 PB12 Pour les autres ports regarder la page 176 de la doc de la STM32F103Ils peuvent √™tre configur√©s pour fonctionner avec des Standard ou Extended ID.Cependant, on ne peut pas l‚Äôutiliser tout seul, il faut lui associ√© un composant appel√© CAN Transreceiver pour pouvoir s‚Äôen servir. Nous utilisons le mod√®le MCP2551 qui est l‚Äôancienne version du MCP2552 utilis√© mais qui marche toujours. Il est branch√© au CAN de la forme suivante:Vous observerez que nous connectons les deux poins CANH et CANL sur un circuit ferm√© par deux r√©sistances de 120 Ohm. En effet, il n‚Äôa pas de sens envoy√© ou recevoir tous les messages circulent sur ce milieu et sont r√©cup√©r√©s par toutes les STM32 si elles sont en reception. On appelle √ßa un circuit bouchon.2.2. Comment filtrer des messagesCes p√©riph√©riques bxCAN ont des fonctionnalit√©s suppl√©mentaires assez int√©ressantes en termes de filtrage de messages. Elles sont tr√®s utiles, car les messages sont directement filtr√©s par le hardware ce qui allege la charge de travail du processeur. Au club, nous utilisons filtrage par ID et/ou Masque. Il existe plusieurs banques ou configurer les filtres (cf. doc officielle) donc les possibilit√©s sont tr√®s nombreuses. Nous n‚Äôutilisons qu‚Äôune seule banque pour filtrer nos messages parce que c‚Äôest largement suffisant pour notre application.Le filtrage par ID est simple il suffit d‚Äôindiquer au programme que nous voulons juste recevoir des messages avec un ID particuler. Sur rust on le configure de la forme suivante :const u16 ID //inf √† 2¬π¬π si Standard IDlet mut filters = can1.modify_filters();filters.enable_bank(0, BankCOnfig::List16([ListEntry16::data_frames_with_id(StandardId::new(MY_ID).unwarp())]));Le filtrage par Masque/ID et de filtrer de forme plus fine. Elle se compose d‚Äôun masque qui nous indique quels bits il faut regarder (bit √† 1) et lesquels on peut ignorer (√† 0). L‚ÄôID nous donne la valeur que devrait avoir ces bits. Ainsi par exemple si nous voulons filtrer de sorte √† avoir juste des messages avec des IDs pairs nous configurons notre masque et notre ID tel que (pour des ID standards √† 11 bits): Masque : 0x001 (dernier bit √† 1) ID : 0x000 (dernier bit √† 0)Avec cette configuration, nous allons recevoir que des messages avec un ID qui ont le dernier bit √† 0 soit des ID pairs. De forme analogue si on configure les registres tels que : Masque : 0x001 (dernier bit √† 1) ID : 0x001 (dernier bit √† 0)Nous allons recevoir que des messages √† ID impair.Pour faire cette configuration nous utilisons le code suivant :let mut filters = can1.modify_filters();filters.enable_bank(0, Mask32::frames_with_std_id( StandardId::new(0x000).unwrap(), //ID StandardId::new(0x001).unwrap())); //masque3. Comment tester le CAN bus3.1. Carte de prototypagePour tester le CAN Bus avant de l‚Äôembarqu√© nous avons fabriqu√© 3 cartes de protypage (ID de carte AAB) qui permettent d‚Äôutiliser le CAN Transreceiver avec une plaquette d‚Äôessai . Vous trouverez le circuit et le Typhoon pour la fabriqu√©e ici. Les MCP2551 sont des composants mont√©s en surface (CMS) et donc on n‚Äôa pas acc√®s aux diff√©rents PIN directement.3.2. Mise en routeIl faut brancher la carte et le bus tel qu‚Äôindiqu√© dans le 2.1. Il ne faut surtout pas oublier les resistances bouchons en bord du bus de 120 Ohm au pin RS. Il faut faire gaffe aussi √† bien brancher la r√©sistance de 10 kOhm, en effet, c‚Äôest elle qui permet de fixer mode de fonctionnement du MCP (High speed, Slope-control et Standby Mode). Nous sommes en Slope-Control et on a fix√© une vitesse de balayage (slew-rate) de environ 23V/us. Cette vitesse de balayage limite le d√©bit du CAN Bus qu‚Äôon fixe logiciellement.Il existe d√©j√† un banc test d√©j√† brancher pour tester. Donc normalement pas besion de refaire tout ceci.On alimente tout le circuit en 5V pour √™tre s√ªr d‚Äôavoir une tension stable pour les MCP. Il faut mettre au moins 2 MCP sur le r√©seau. On ne peut pas tester le CAN Bus seul car il a besoin de recevoir des ACK pour √™tre s√ªrs que les messages ont √©t√© bien envoy√©s.Pour commencer √† envoyer des messages et √† en recevoir, il faut flasher la STM32 avec le code qui est dans la branche can-bus de ce repo Github. Le code est comment√© et devrait √™tre semi-compr√©hensible. Il permet d‚Äôafficher sur la console du debugger les messages re√ßus. Le code pour envoyer des messages est comment√© et pr√©sent dans le loop. Si votre STM est d√©j√† aliment√© par les +5V des MCP vous pouvez d√©brancher le pin 3V3 du c√¢ble de flash. Il n‚Äôest pas n√©cessaire.3.3. Configurations possiblesVous pouvez soit flasher deux STM entre elles et les faire communiquer mais vous pouvez aussi connecter la raspberry Pi avec son module CAN aussi. Pour voir comment faire du CAN avec la raspberry Pi se r√©f√©rer √† [cette page]" }, { "title": "Tirage cartes √©lectroniques au FabLab", "url": "/docs/posts/tirage-cartes/", "categories": "2022, tirage cartes", "tags": "post, tutorial, elec-hard, fablab", "date": "2022-03-11 00:00:00 +0100", "snippet": "Tirage cartes1. Cr√©er la carte avec kikad2. l‚Äôexporter comme SVGApr√©s l‚Äôavoir export√© enlever toutes les parties inutiles jor les lignes de marge du plan.3. Imprimer en s√©lectionnant type d‚Äôimpression sur du papier transparentDans les propri√©t√©s d‚Äôimpression il faut s√©lectionner du papier transparent pour que l‚Äôimprimante mette plus d‚Äôencre ( pas utiliser economisation d‚Äôancre ) et bien marquer la carte sur le papier. Bien s‚Äôassurer que toutes les lignes sont continues et que l‚Äôimage n‚Äôa pas de s√©paration entre les pixels.One peut exporter en PDF avant pour avoir une pr√©visualisation de l‚Äôimpression.Avant d‚Äôimprimer avec du papier transparent on peut l‚Äôimprimer en papier ‚Äúnormal‚Äù pour voir si la position de l‚Äôimpression est correcte.Les papiers transparents doivent avoir un bout droit sinon l‚Äôimprimante ne les aime pas üòñ ;4. Suivre le livret d‚Äôimpression de cartes au fablab1.Couper une carte dans la taille plus petite possible ( laisser de l‚Äôespace pour coller le film sur la r√©sine )‚ö†Ô∏è Prendre les plaques √† simple face si possible elles sont moins ch√®res üòÖ.2.Retirer la protection de la r√©sine ( truc bleu coll√© )3.Coller le film avec du scotch √† la r√©sine4.Poser la carte avec le film coll√© dans l‚Äô√©metteur d‚Äôultraviolets ( face de l‚Äôimpression contre les ultraviolets )5.Retirer le film ( le garder pour faire plus de cartes plus tard )6.Mettre la r√©sine dans le releveur ( liquide orange|marron ) pour 30 s jusqu‚Äô√† 2 min jusqu‚Äô√† voir notre circuit appara√Ætre sur la carte7.Une fois on voit notre circuit sur la carte on la nettoie √† l‚Äôeau8.On met la carte dans l‚Äôacide ( truc bleu ) et on active tout ( pompes, chaleur, lumi√®re et ventilation ). On la laisse dans l‚Äôacide minimum 20min et jusqu‚Äô√† voir que la carte n‚Äôest plus rose|marron ( il n‚Äôy a plus de cuivre o√π il ne devrait pas y en avoir ). On peut laisser la carte dans l‚Äôacide autant qu‚Äôon veut tandis que le cuivre dans la zone o√π on veut le garder ne commence pas √† s‚Äôenlever.9.Rincer la carte dans l‚Äôeau10.Passer du papier ou coton avec de l‚Äôac√©tone pour enlever la r√©sine sur le cuivre restant11.Normalement on a une carte fonctionnelle ( pas toujours üòÇ )Par exemple cette carte n‚Äôest pas bonne, elle a encore du cuivre par tout, tout est connect√© avec tout c‚Äôest inutile :√áa c‚Äôest la bonne couleur:" }, { "title": "Saleae logic analyzer", "url": "/docs/posts/saleae-logic-analyzer/", "categories": "2022, logic-analyzer", "tags": "post, tutorial, elec-soft, can-bus, d√©bogage", "date": "2022-03-11 00:00:00 +0100", "snippet": "Saleae logic analyzerD√©bogage du bus CAN et protocoles de communication en g√©n√©ral. Installer le software saleae (sous linux) ‚áí pas besoin de software additionnel pour ex√©cuter (appimage) mais ne pas oublier d‚Äôajouter les droits d‚Äôex√©cution Download sur son site ex√©cuter le message cat ‚Ä¶ qui s‚Äôaffiche √† l‚Äôouverture du programme fermer l‚Äôapplication la r√©ouvrir, d√©brancher et rebrancher le logic analyzer du PC la connexion est normalement √©tablieUtilisation: Rajouter un analyzer (barre d‚Äôic√¥nes √† droite) en CAN ‚ö† Le Pin 1 du LogicAnalizer correspond au pin 0 sur le programme!!!! ( oui c‚Äô√©tait trop facile sinon ) Lancer l‚Äôacquisition (Start en haut √† droite)" }, { "title": "Some help for redaction", "url": "/docs/posts/some-help-for-redaction/", "categories": "2022, moderation", "tags": "post, tutorial, jekyll", "date": "2021-12-25 16:53:00 +0100", "snippet": "In this post you will find all required information for posting in this websiteMarkdown (.md) redactionAt first you have to take a look on markdown syntax hereImage exampleIf you need place some images in your posts. Use the following syntax.![Alt word if image isn&#39;t loaded](/assets/img/favicons/android-chrome-512x512.png){: width=&quot;200&quot; height=&quot;100&quot;}*Image description phrase*For each image the width and the height are in pixels.You can save your images on /assets/img/posts or just use the url instead (Ex. https://ursd.org/wp-content/uploads/2020/12/1.png).Result :Few words about imageCode blockJekyll supports several types of code blocksFor any code you can use```code```ResultLiterally any codeThere is a possibility to specify the programming language```rustcode```Result!print(&quot;Hello world!&quot;)About post configurationYou can find a template for posts at main branch named post_template.mdYou have to name it in several way: YYYY-DD-MM-some-title.mdThere are some details to add.title: The main titledate: dd/mm/yy hh:mm:ss +0800categories: [&quot;year&quot;, category2] # Up to 2 categoriestags: [tag1,tag2,tag3] # You can add as much tags as you wish (but dont abuse)author: name: Your name link: https://github.com/YourGithubUsernameimage: src: image url width: # in pixels height: # in pixels alt: alternative text # An alternative text which will appear if the image isn&#39;t loaded" } ]
