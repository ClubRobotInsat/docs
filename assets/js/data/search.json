[ { "title": "First test to try the documentation", "url": "/docs/posts/Test/", "categories": "2023, test", "tags": "post, test", "date": "2023-11-18 15:55:00 +0100", "snippet": "This is a test to try the documentation." }, { "title": "CAN Bus avec Raspberry Pi", "url": "/docs/posts/CAN-Bus-avec-RaspberryPi/", "categories": "2022, can-bus", "tags": "post, elec-soft, can-bus, raspberryPi, protocol, info", "date": "2022-10-21 05:26:00 +0200", "snippet": "1. Brancher le Composant intermÃ©diaire CAN - RaspberryPI2. Commandes de test en bash3. Librairie python CANpy ?" }, { "title": "Network Protocol Definition", "url": "/docs/posts/Network-Protocol/", "categories": "2022, can-bus", "tags": "elec-soft, can-bus, info, network", "date": "2022-04-08 00:00:00 +0200", "snippet": "Ce document dÃ©crit le fonctionnement du protocole utilisÃ© pour les communications entre les microcontroleurs du robot et la raspi.Câ€™est un protocole sans pertes c.-Ã -d. toutes les trames sont vÃ©rifiÃ©es avec un paquet dâ€™acquittement avant de les marquÃ©s comme bien envoyÃ©s. Trame sur 64 bits Â  Â  Â  Â  Â  4b 4b 3b 4b 1b 48b ID_dest ID_sender ID_mess seq_num ACK data Name Type Explication ID_dest unsigned (4bit) ID de la STM auquelle le message va dirigÃ© ID_sender unsigned (4bit) ID de la STM qui envoie le message ID_mess unsigned (3bit) Identificateur unique du message. La combinaison (ID_sender,ID_des,ID_mess) doit Ãªtre unique. cela veut dire quâ€™on ne peux pas envoyer un message avec la mÃªme idÃ©e tant quâ€™on a pas liberÃ©e la ID ( la ID est liberÃ©e quand on a reÃ§u tous les ACK des trames du message ) seq_num unsigned (4bit) Numero de sequence de la trame. âš  On le decremente. Ce numero indique la lâ€™ordre de la trame pour permetre de reconstruire le message bien ordonÃ©. On le decremante, cela implique que la premiÃ¨re trame indique le nÃºmero de trames qui forment le message. ACK bool (1b) Indique si la trame est un paquet dâ€™acquittement ExamplesSTM(ID:4) &amp;lt;â€”â€”â€”â€”â€”â€”-&amp;gt; STM(ID:12)STM4 evnoye un message Ã  STM12:Notre message: Club_Robot_INSATTaille du message = 16bytes ( codÃ© en ASCII )Cela veut dire quâ€™il faut diviser notre message en 3 trames de 6 bytes. ( 16 / 6 = 3 ) ( on pourrait coder des espaces sans problemme mais câ€™est compliquer Ã  les Ã©crire dâ€™una faÃ§on claire pour lâ€™example ğŸ˜…)3 messages =&amp;gt; seq_num = 2 de la premiÃ¨re trameOn prend lâ€™id_mess = 0, car câ€™est le premier message quâ€™on evoye.Trames envoyÃ©s par le STM4: [12,4,0,2,0,C,l,u,b,_,R] [12,4,0,1,0,o,b,o,t,_,I] [12,4,0,0,0,N,S,A,T,0,0] -&amp;gt; On rempli avec des 0â€™s le reste du messageTrames envoyÃ©es par le STM12 ( ACK ): [4,12,0,2,1,0,0,0,0,0,0] [4,12,0,1,1,0,0,0,0,0,0] [4,12,0,0,1,0,0,0,0,0,0]Si maintenant on veut envoyer un autre message il faut juste augmenter lâ€™id_mess mod 7." }, { "title": "Notre microcontrÃ´leur: le STM32F103", "url": "/docs/posts/Microcontroleur-STM32/", "categories": "2022, can-bus", "tags": "post, tutorial, elec-soft, stm32, microcontroleur", "date": "2022-03-17 00:00:00 +0100", "snippet": "Pour gÃ©rer les actionneurs, moteurs et capteurs, nous utilisons des microcontrÃ´leurs rÃ©partis dans tout le robot. Parmi ceux existant nous utilisons des STM32F103 comme dans les TPs de 4A Ã  lâ€™INSA.Un microcontrÃ´leur est un â€petitâ€ maid qui ne possÃ¨de pas de systÃ¨me dâ€™exploitation, il est vide. Ainsi, câ€™est nous qui devons Ã©crire le code qui va sâ€™exÃ©cuter sur lui, le firmaware (entre soft et hardware) puis le transmettre Ã  ce dernier.Cette action se nomme flasher le contrÃ´leur. Une fois le contrÃ´leur a Ã©tÃ© flashÃ© il garde le programme Ã  exÃ©cuter dans sa mÃ©moire morte et une fois mis sur tension il sâ€™exÃ©cutera.Si vous observez les microcontrÃ´leurs au Club, vous vous rendrez compte quâ€™ils possÃ¨dent un gran nombre de pins (48 dans notre cas). Chacun porte un nom spÃ©cial et a aussi des fonctions dÃ©signÃ©es. Nous avons des pins de GND, de source de tension, mais aussi des GPIOs (General Purpose Input Output) qui nous permettent de communiquer avec lâ€™extÃ©rieur. Ces derniers peuvent Ãªtre configurÃ©s par le programmeur pour rÃ©pondre Ã  ses besoins. Pour fixer cette configuration, nous devons affecter certaines valeurs spÃ©ciales aux registres de control de chacun deses ports. GrÃ¢ce Ã  la librairie HAL (High Applicative Layer) nous nâ€™aurons pas besoin de le faire directement, mais en appelant leurs mÃ©thodes. Regarder le code firmware commentÃ© pour comprendre les Ã©tapes de configuration.De plus, selon le pÃ©riphÃ©rique que nous souhaitons utilisÃ© ces ports vont devoir Ãªtre configurÃ© selon une configuration prÃ©cise. Pour trouver toutes les configurations pour chaque pÃ©riphÃ©rique il faut regarder dans le reference manual RM0008 Ã  la page 166. Pour voir sur quels pins sont branchÃ©s tous les pÃ©riphÃ©riques (USART, Timer, etc..) il faut voir la page 176.Les diffÃ©rentes configurations des ports GPIO possibles sont : Mode Input Utilisation Floating Input Mode standard, prend lâ€™entrÃ©e tel quel sans tensions de rÃ©fÃ©rence Input with pull-up/pull-down EntrÃ©e digital avec rÃ©ference au GND ou Ã  la tension de polarisation (Vcc) selon Ã  quel potentiel on branche la rÃ©sistance Analog Input Pour signaux analogiques (ADC ou CAN) Mode Output Utilisation General purpose output push-pull Le composant sera alimentÃ© par pin de sortie General purpose output Open-drain Composant alimentÃ© par nous. Besoin dâ€™une rÃ©sistance pull-up (au VCC) pour assurer le niveau logique â€™1â€™ Alternate function output Push-pull Configuration spÃ©ciale pour utiliser certains pÃ©riphÃ©riques Alternate function output Open-drain Configuration spÃ©ciale pour utiliser certains pÃ©riphÃ©riques. VÃ©rifier le besoin dâ€™un rÃ©sistance pull-up Dernier point important sur le clock. Câ€™est le signal qui synchronise et fait marcher tout le systÃ¨me. Ainsi vous observerez dans le code quâ€™avant dâ€™utiliser nâ€™importe quel GPIO il faut alimenter leur branche par une clock pour les activer. Chaque pÃ©riphÃ©rique est sur une des deux branches qui existent avec chacune une frÃ©quence maximale diffÃ©rente de fonctionnement (ceci est important pour les protocoles de communication notamment de type USART)." }, { "title": "CAN Bus", "url": "/docs/posts/CAN-Bus-driver/", "categories": "2022, can-bus", "tags": "post, elec-soft, can-bus", "date": "2022-03-15 12:28:00 +0100", "snippet": "1. Presentation du protocoleLe protocole utilisÃ© pour communiquer entre les microcontrÃ´leurs STM32 et le â€œcerveauâ€ du robot, la Raspberry Pi est le CAN Bus. TrÃ¨s utilisÃ© en industrie notamment dans le domaine de lâ€™automobile, nous lâ€™avons choisi car il permet de transmettre les messages avec juste 2 cables nommÃ© CAN High et CAN Low.1.1. AvantagesCe protocole a de nombreux avantages : Il prÃ©sente une grande fiabilitÃ©. En effet, il implÃ©mente 5 moyens diffÃ©rents de dÃ©tection dâ€™erreurs et est capable de dÃ©tecter une erreur en 20 bits. Ainsi pour notre dÃ©bit de 115Kb/, une erreur est dÃ©tectÃ© moins de 1 ms. Elles sont de plus trÃ¨s rares grÃ¢ce aux propriÃ©tÃ©s Ã©lectromagnÃ©tiques du bus. Lâ€™acquittement de reception est gÃ©rer par le hardware associÃ© au CAN. DOnc il nâ€™y a pas besoin de traiter les ACK logiciellement. Le renvoi de message en cas dâ€™Ã©chec dâ€™envoi se fait aussi par hardware. DÃ©bits suffisamment Ã©levÃ©s pouvant atteindre un 1 Mbit/s. Gestion des collisions entre messages. Si plusieurs machines sur le rÃ©seau dÃ©cide dâ€™envoyer un message en mÃªme temps, le message le plus prioritaire sera envoyer en premier (cf. partie 1.2.).1.2. Format des tramesLes trames CAN sont composÃ© de 2 parties, la partie ID et la partie donnÃ©es. Cependant, le concept de ID ne correspond pas Ã  lâ€™idÃ©e dâ€™avoir un identificateur pour les diffÃ©rentes machines du rÃ©seau. En revanche, il se rÃ©fÃ¨re Ã  la prioritÃ© des messages qui permet de choisir quel message sera envoyer en premier en cas de collisions dans le rÃ©seau. Ce sera le message de plus haute prioritÃ© qui sera Ã©mis en cas de conflit. Dans la documentation, on se rÃ©fÃ¨re Ã  cette prioritÃ© comme lâ€™identificateur de message (ID) mÃªme si ce nâ€™est pas exactement Ã§a. Il existe deux versions de ID (prioritÃ©) selon la quel la taille du champ prioritÃ©/ID des messages change : Standard CAN ID: Taille de 11 bits Extended CAN ID: Taille de 29 bitsLa zone data a une taille maximale entre 0 et 8 octets soit 64 bits au total.Pour avoir plus dâ€™informations techniques sur le CAN vous pouvez clickez ici2. UtilisÃ© le CAN BUS avec des STM322.1. Comment utilsier le pÃ©riphÃ©rique bxCANNotre microcontroleur STM32 possÃ¨de deux pÃ©riphÃ©riques internes capables de faire du CAN Bus appelÃ©s bxCAN. Si on ne fait pas de remap sur notre STM32 ils sont accesibles via les ports suivants: nÂº CAN TXD RXD CAN 1 PA12 PA11 CAN 2 PB13 PB12 Pour les autres ports regarder la page 176 de la doc de la STM32F103Ils peuvent Ãªtre configurÃ©s pour fonctionner avec des Standard ou Extended ID.Cependant, on ne peut pas lâ€™utiliser tout seul, il faut lui associÃ© un composant appelÃ© CAN Transreceiver pour pouvoir sâ€™en servir. Nous utilisons le modÃ¨le MCP2551 qui est lâ€™ancienne version du MCP2552 utilisÃ© mais qui marche toujours. Il est branchÃ© au CAN de la forme suivante:Vous observerez que nous connectons les deux poins CANH et CANL sur un circuit fermÃ© par deux rÃ©sistances de 120 Ohm. En effet, il nâ€™a pas de sens envoyÃ© ou recevoir tous les messages circulent sur ce milieu et sont rÃ©cupÃ©rÃ©s par toutes les STM32 si elles sont en reception. On appelle Ã§a un circuit bouchon.2.2. Comment filtrer des messagesCes pÃ©riphÃ©riques bxCAN ont des fonctionnalitÃ©s supplÃ©mentaires assez intÃ©ressantes en termes de filtrage de messages. Elles sont trÃ¨s utiles, car les messages sont directement filtrÃ©s par le hardware ce qui allege la charge de travail du processeur. Au club, nous utilisons filtrage par ID et/ou Masque. Il existe plusieurs banques ou configurer les filtres (cf. doc officielle) donc les possibilitÃ©s sont trÃ¨s nombreuses. Nous nâ€™utilisons quâ€™une seule banque pour filtrer nos messages parce que câ€™est largement suffisant pour notre application.Le filtrage par ID est simple il suffit dâ€™indiquer au programme que nous voulons juste recevoir des messages avec un ID particuler. Sur rust on le configure de la forme suivante :const u16 ID //inf Ã  2Â¹Â¹ si Standard IDlet mut filters = can1.modify_filters();filters.enable_bank(0, BankCOnfig::List16([ListEntry16::data_frames_with_id(StandardId::new(MY_ID).unwarp())]));Le filtrage par Masque/ID et de filtrer de forme plus fine. Elle se compose dâ€™un masque qui nous indique quels bits il faut regarder (bit Ã  1) et lesquels on peut ignorer (Ã  0). Lâ€™ID nous donne la valeur que devrait avoir ces bits. Ainsi par exemple si nous voulons filtrer de sorte Ã  avoir juste des messages avec des IDs pairs nous configurons notre masque et notre ID tel que (pour des ID standards Ã  11 bits): Masque : 0x001 (dernier bit Ã  1) ID : 0x000 (dernier bit Ã  0)Avec cette configuration, nous allons recevoir que des messages avec un ID qui ont le dernier bit Ã  0 soit des ID pairs. De forme analogue si on configure les registres tels que : Masque : 0x001 (dernier bit Ã  1) ID : 0x001 (dernier bit Ã  0)Nous allons recevoir que des messages Ã  ID impair.Pour faire cette configuration nous utilisons le code suivant :let mut filters = can1.modify_filters();filters.enable_bank(0, Mask32::frames_with_std_id( StandardId::new(0x000).unwrap(), //ID StandardId::new(0x001).unwrap())); //masque3. Comment tester le CAN bus3.1. Carte de prototypagePour tester le CAN Bus avant de lâ€™embarquÃ© nous avons fabriquÃ© 3 cartes de protypage (ID de carte AAB) qui permettent dâ€™utiliser le CAN Transreceiver avec une plaquette dâ€™essai . Vous trouverez le circuit et le Typhoon pour la fabriquÃ©e ici. Les MCP2551 sont des composants montÃ©s en surface (CMS) et donc on nâ€™a pas accÃ¨s aux diffÃ©rents PIN directement.3.2. Mise en routeIl faut brancher la carte et le bus tel quâ€™indiquÃ© dans le 2.1. Il ne faut surtout pas oublier les resistances bouchons en bord du bus de 120 Ohm au pin RS. Il faut faire gaffe aussi Ã  bien brancher la rÃ©sistance de 10 kOhm, en effet, câ€™est elle qui permet de fixer mode de fonctionnement du MCP (High speed, Slope-control et Standby Mode). Nous sommes en Slope-Control et on a fixÃ© une vitesse de balayage (slew-rate) de environ 23V/us. Cette vitesse de balayage limite le dÃ©bit du CAN Bus quâ€™on fixe logiciellement.Il existe dÃ©jÃ  un banc test dÃ©jÃ  brancher pour tester. Donc normalement pas besion de refaire tout ceci.On alimente tout le circuit en 5V pour Ãªtre sÃ»r dâ€™avoir une tension stable pour les MCP. Il faut mettre au moins 2 MCP sur le rÃ©seau. On ne peut pas tester le CAN Bus seul car il a besoin de recevoir des ACK pour Ãªtre sÃ»rs que les messages ont Ã©tÃ© bien envoyÃ©s.Pour commencer Ã  envoyer des messages et Ã  en recevoir, il faut flasher la STM32 avec le code qui est dans la branche can-bus de ce repo Github. Le code est commentÃ© et devrait Ãªtre semi-comprÃ©hensible. Il permet dâ€™afficher sur la console du debugger les messages reÃ§us. Le code pour envoyer des messages est commentÃ© et prÃ©sent dans le loop. Si votre STM est dÃ©jÃ  alimentÃ© par les +5V des MCP vous pouvez dÃ©brancher le pin 3V3 du cÃ¢ble de flash. Il nâ€™est pas nÃ©cessaire.3.3. Configurations possiblesVous pouvez soit flasher deux STM entre elles et les faire communiquer mais vous pouvez aussi connecter la raspberry Pi avec son module CAN aussi. Pour voir comment faire du CAN avec la raspberry Pi se rÃ©fÃ©rer Ã  [cette page]" }, { "title": "Tirage cartes Ã©lectroniques au FabLab", "url": "/docs/posts/tirage-cartes/", "categories": "2022, tirage cartes", "tags": "post, tutorial, elec-hard, fablab", "date": "2022-03-11 00:00:00 +0100", "snippet": "Tirage cartes1. CrÃ©er la carte avec kikad2. lâ€™exporter comme SVGAprÃ©s lâ€™avoir exportÃ© enlever toutes les parties inutiles jor les lignes de marge du plan.3. Imprimer en sÃ©lectionnant type dâ€™impression sur du papier transparentDans les propriÃ©tÃ©s dâ€™impression il faut sÃ©lectionner du papier transparent pour que lâ€™imprimante mette plus dâ€™encre ( pas utiliser economisation dâ€™ancre ) et bien marquer la carte sur le papier. Bien sâ€™assurer que toutes les lignes sont continues et que lâ€™image nâ€™a pas de sÃ©paration entre les pixels.One peut exporter en PDF avant pour avoir une prÃ©visualisation de lâ€™impression.Avant dâ€™imprimer avec du papier transparent on peut lâ€™imprimer en papier â€œnormalâ€ pour voir si la position de lâ€™impression est correcte.Les papiers transparents doivent avoir un bout droit sinon lâ€™imprimante ne les aime pas ğŸ˜– ;4. Suivre le livret dâ€™impression de cartes au fablab1.Couper une carte dans la taille plus petite possible ( laisser de lâ€™espace pour coller le film sur la rÃ©sine )âš ï¸ Prendre les plaques Ã  simple face si possible elles sont moins chÃ¨res ğŸ˜….2.Retirer la protection de la rÃ©sine ( truc bleu collÃ© )3.Coller le film avec du scotch Ã  la rÃ©sine4.Poser la carte avec le film collÃ© dans lâ€™Ã©metteur dâ€™ultraviolets ( face de lâ€™impression contre les ultraviolets )5.Retirer le film ( le garder pour faire plus de cartes plus tard )6.Mettre la rÃ©sine dans le releveur ( liquide orange|marron ) pour 30 s jusquâ€™Ã  2 min jusquâ€™Ã  voir notre circuit apparaÃ®tre sur la carte7.Une fois on voit notre circuit sur la carte on la nettoie Ã  lâ€™eau8.On met la carte dans lâ€™acide ( truc bleu ) et on active tout ( pompes, chaleur, lumiÃ¨re et ventilation ). On la laisse dans lâ€™acide minimum 20min et jusquâ€™Ã  voir que la carte nâ€™est plus rose|marron ( il nâ€™y a plus de cuivre oÃ¹ il ne devrait pas y en avoir ). On peut laisser la carte dans lâ€™acide autant quâ€™on veut tandis que le cuivre dans la zone oÃ¹ on veut le garder ne commence pas Ã  sâ€™enlever.9.Rincer la carte dans lâ€™eau10.Passer du papier ou coton avec de lâ€™acÃ©tone pour enlever la rÃ©sine sur le cuivre restant11.Normalement on a une carte fonctionnelle ( pas toujours ğŸ˜‚ )Par exemple cette carte nâ€™est pas bonne, elle a encore du cuivre par tout, tout est connectÃ© avec tout câ€™est inutile :Ã‡a câ€™est la bonne couleur:" }, { "title": "Saleae logic analyzer", "url": "/docs/posts/saleae-logic-analyzer/", "categories": "2022, logic-analyzer", "tags": "post, tutorial, elec-soft, can-bus, dÃ©bogage", "date": "2022-03-11 00:00:00 +0100", "snippet": "Saleae logic analyzerDÃ©bogage du bus CAN et protocoles de communication en gÃ©nÃ©ral. Installer le software saleae (sous linux) â‡’ pas besoin de software additionnel pour exÃ©cuter (appimage) mais ne pas oublier dâ€™ajouter les droits dâ€™exÃ©cution Download sur son site exÃ©cuter le message cat â€¦ qui sâ€™affiche Ã  lâ€™ouverture du programme fermer lâ€™application la rÃ©ouvrir, dÃ©brancher et rebrancher le logic analyzer du PC la connexion est normalement Ã©tablieUtilisation: Rajouter un analyzer (barre dâ€™icÃ´nes Ã  droite) en CAN âš  Le Pin 1 du LogicAnalizer correspond au pin 0 sur le programme!!!! ( oui câ€™Ã©tait trop facile sinon ) Lancer lâ€™acquisition (Start en haut Ã  droite)" }, { "title": "Some help for redaction", "url": "/docs/posts/some-help-for-redaction/", "categories": "2022, moderation", "tags": "post, tutorial, jekyll", "date": "2021-12-25 16:53:00 +0100", "snippet": "In this post you will find all required information for posting in this websiteMarkdown (.md) redactionAt first you have to take a look on markdown syntax hereImage exampleIf you need place some images in your posts. Use the following syntax.![Alt word if image isn&#39;t loaded](/assets/img/favicons/android-chrome-512x512.png){: width=&quot;200&quot; height=&quot;100&quot;}*Image description phrase*For each image the width and the height are in pixels.You can save your images on /assets/img/posts or just use the url instead (Ex. https://ursd.org/wp-content/uploads/2020/12/1.png).Result :Few words about imageCode blockJekyll supports several types of code blocksFor any code you can use```code```ResultLiterally any codeThere is a possibility to specify the programming language```rustcode```Result!print(&quot;Hello world!&quot;)About post configurationYou can find a template for posts at main branch named post_template.mdYou have to name it in several way: YYYY-DD-MM-some-title.mdThere are some details to add.title: The main titledate: dd/mm/yy hh:mm:ss +0800categories: [&quot;year&quot;, category2] # Up to 2 categoriestags: [tag1,tag2,tag3] # You can add as much tags as you wish (but dont abuse)author: name: Your name link: https://github.com/YourGithubUsernameimage: src: image url width: # in pixels height: # in pixels alt: alternative text # An alternative text which will appear if the image isn&#39;t loaded" } ]
